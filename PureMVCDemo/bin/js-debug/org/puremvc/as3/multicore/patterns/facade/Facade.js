/**
 * Generated by Apache Flex Cross-Compiler from org\puremvc\as3\multicore\patterns\facade\Facade.as
 * org.puremvc.as3.multicore.patterns.facade.Facade
 *
 * @fileoverview
 *
 * @suppress {checkTypes|accessControls}
 */

goog.provide('org.puremvc.as3.multicore.patterns.facade.Facade');

goog.require('org.puremvc.as3.multicore.core.Controller');
goog.require('org.puremvc.as3.multicore.core.Model');
goog.require('org.puremvc.as3.multicore.core.View');
goog.require('org.puremvc.as3.multicore.patterns.observer.Notification');
goog.require('org.puremvc.as3.multicore.interfaces.IFacade');
goog.require('org.puremvc.as3.multicore.interfaces.IMediator');
goog.require('org.apache.flex.utils.Language');



/**
 * Constructor. 
 * 
 * <P>
 * This <code>IFacade</code> implementation is a Multiton, 
 * so you should not call the constructor 
 * directly, but instead call the static Factory method, 
 * passing the unique key for this instance 
 * <code>Facade.getInstance( multitonKey )</code>
 * 
 * @throws Error Error if instance for this Multiton key has already been constructed
 * 
 * @constructor
 * @implements {org.puremvc.as3.multicore.interfaces.IFacade}
 * @param {string} key
 */
org.puremvc.as3.multicore.patterns.facade.Facade = function(key) {
  if (org.puremvc.as3.multicore.patterns.facade.Facade.instanceMap[key] != null)
    throw Error(this.MULTITON_MSG);
  this.initializeNotifier(key);
  org.puremvc.as3.multicore.patterns.facade.Facade.instanceMap[this.multitonKey] = this;
  this.initializeFacade();
};


/**
 * Initialize the Multiton <code>Facade</code> instance.
 * 
 * <P>
 * Called automatically by the constructor. Override in your
 * subclass to do any subclass specific initializations. Be
 * sure to call <code>super.initializeFacade()</code>, though.</P>
 * @protected
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.initializeFacade = function() {
  this.initializeModel();
  this.initializeController();
  this.initializeView();
};


/**
 * Facade Multiton Factory method
 * 
 * @asreturn the Multiton instance of the Facade
 * @export
 * @param {string} key
 * @return {org.puremvc.as3.multicore.interfaces.IFacade}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.getInstance = function(key) {
  if (org.puremvc.as3.multicore.patterns.facade.Facade.instanceMap[key] == null)
    org.puremvc.as3.multicore.patterns.facade.Facade.instanceMap[key] = new org.puremvc.as3.multicore.patterns.facade.Facade(key);
  return org.puremvc.as3.multicore.patterns.facade.Facade.instanceMap[key];
};


/**
 * Initialize the <code>Controller</code>.
 * 
 * <P>
 * Called by the <code>initializeFacade</code> method.
 * Override this method in your subclass of <code>Facade</code> 
 * if one or both of the following are true:
 * <UL>
 * <LI> You wish to initialize a different <code>IController</code>.</LI>
 * <LI> You have <code>Commands</code> to register with the <code>Controller</code> at startup.</code>. </LI>		  
 * </UL>
 * If you don't want to initialize a different <code>IController</code>, 
 * call <code>super.initializeController()</code> at the beginning of your
 * method, then register <code>Command</code>s.
 * </P>
 * @protected
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.initializeController = function() {
  if (this.controller != null)
    return;
  this.controller = org.puremvc.as3.multicore.core.Controller.getInstance(this.multitonKey);
};


/**
 * Initialize the <code>Model</code>.
 * 
 * <P>
 * Called by the <code>initializeFacade</code> method.
 * Override this method in your subclass of <code>Facade</code> 
 * if one or both of the following are true:
 * <UL>
 * <LI> You wish to initialize a different <code>IModel</code>.</LI>
 * <LI> You have <code>Proxy</code>s to register with the Model that do not 
 * retrieve a reference to the Facade at construction time.</code></LI> 
 * </UL>
 * If you don't want to initialize a different <code>IModel</code>, 
 * call <code>super.initializeModel()</code> at the beginning of your
 * method, then register <code>Proxy</code>s.
 * <P>
 * Note: This method is <i>rarely</i> overridden; in practice you are more
 * likely to use a <code>Command</code> to create and register <code>Proxy</code>s
 * with the <code>Model</code>, since <code>Proxy</code>s with mutable data will likely
 * need to send <code>INotification</code>s and thus will likely want to fetch a reference to 
 * the <code>Facade</code> during their construction. 
 * </P>
 * @protected
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.initializeModel = function() {
  if (this.model != null)
    return;
  this.model = org.puremvc.as3.multicore.core.Model.getInstance(this.multitonKey);
};


/**
 * Initialize the <code>View</code>.
 * 
 * <P>
 * Called by the <code>initializeFacade</code> method.
 * Override this method in your subclass of <code>Facade</code> 
 * if one or both of the following are true:
 * <UL>
 * <LI> You wish to initialize a different <code>IView</code>.</LI>
 * <LI> You have <code>Observers</code> to register with the <code>View</code></LI>
 * </UL>
 * If you don't want to initialize a different <code>IView</code>, 
 * call <code>super.initializeView()</code> at the beginning of your
 * method, then register <code>IMediator</code> instances.
 * <P>
 * Note: This method is <i>rarely</i> overridden; in practice you are more
 * likely to use a <code>Command</code> to create and register <code>Mediator</code>s
 * with the <code>View</code>, since <code>IMediator</code> instances will need to send 
 * <code>INotification</code>s and thus will likely want to fetch a reference 
 * to the <code>Facade</code> during their construction. 
 * </P>
 * @protected
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.initializeView = function() {
  if (this.view != null)
    return;
  this.view = org.puremvc.as3.multicore.core.View.getInstance(this.multitonKey);
};


/**
 * Register an <code>ICommand</code> with the <code>Controller</code> by Notification name.
 * 
 * @asparam notificationName the name of the <code>INotification</code> to associate the <code>ICommand</code> with
 * @asparam commandClassRef a reference to the Class of the <code>ICommand</code>
 * @export
 * @param {string} notificationName
 * @param {Object} commandClassRef
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.registerCommand = function(notificationName, commandClassRef) {
  this.controller.registerCommand(notificationName, commandClassRef);
};


/**
 * Remove a previously registered <code>ICommand</code> to <code>INotification</code> mapping from the Controller.
 * 
 * @asparam notificationName the name of the <code>INotification</code> to remove the <code>ICommand</code> mapping for
 * @export
 * @param {string} notificationName
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.removeCommand = function(notificationName) {
  this.controller.removeCommand(notificationName);
};


/**
 * Check if a Command is registered for a given Notification 
 * 
 * @asparam notificationName
 * @asreturn whether a Command is currently registered for the given <code>notificationName</code>.
 * @export
 * @param {string} notificationName
 * @return {boolean}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.hasCommand = function(notificationName) {
  return this.controller.hasCommand(notificationName);
};


/**
 * Register an <code>IProxy</code> with the <code>Model</code> by name.
 * 
 * @asparam proxyName the name of the <code>IProxy</code>.
 * @asparam proxy the <code>IProxy</code> instance to be registered with the <code>Model</code>.
 * @export
 * @param {org.puremvc.as3.multicore.interfaces.IProxy} proxy
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.registerProxy = function(proxy) {
  this.model.registerProxy(proxy);
};


/**
 * Retrieve an <code>IProxy</code> from the <code>Model</code> by name.
 * 
 * @asparam proxyName the name of the proxy to be retrieved.
 * @asreturn the <code>IProxy</code> instance previously registered with the given <code>proxyName</code>.
 * @export
 * @param {string} proxyName
 * @return {org.puremvc.as3.multicore.interfaces.IProxy}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.retrieveProxy = function(proxyName) {
  return this.model.retrieveProxy(proxyName);
};


/**
 * Remove an <code>IProxy</code> from the <code>Model</code> by name.
 *
 * @asparam proxyName the <code>IProxy</code> to remove from the <code>Model</code>.
 * @asreturn the <code>IProxy</code> that was removed from the <code>Model</code>
 * @export
 * @param {string} proxyName
 * @return {org.puremvc.as3.multicore.interfaces.IProxy}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.removeProxy = function(proxyName) {
  var /** @type {org.puremvc.as3.multicore.interfaces.IProxy} */ proxy;
  if (this.model != null)
    proxy = this.model.removeProxy(proxyName);
  return proxy;
};


/**
 * Check if a Proxy is registered
 * 
 * @asparam proxyName
 * @asreturn whether a Proxy is currently registered with the given <code>proxyName</code>.
 * @export
 * @param {string} proxyName
 * @return {boolean}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.hasProxy = function(proxyName) {
  return this.model.hasProxy(proxyName);
};


/**
 * Register a <code>IMediator</code> with the <code>View</code>.
 * 
 * @asparam mediatorName the name to associate with this <code>IMediator</code>
 * @asparam mediator a reference to the <code>IMediator</code>
 * @export
 * @param {org.puremvc.as3.multicore.interfaces.IMediator} mediator
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.registerMediator = function(mediator) {
  if (this.view != null)
    this.view.registerMediator(mediator);
};


/**
 * Retrieve an <code>IMediator</code> from the <code>View</code>.
 * 
 * @asparam mediatorName
 * @asreturn the <code>IMediator</code> previously registered with the given <code>mediatorName</code>.
 * @export
 * @param {string} mediatorName
 * @return {org.puremvc.as3.multicore.interfaces.IMediator}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.retrieveMediator = function(mediatorName) {
  return org.apache.flex.utils.Language.as(this.view.retrieveMediator(mediatorName), org.puremvc.as3.multicore.interfaces.IMediator);
};


/**
 * Remove an <code>IMediator</code> from the <code>View</code>.
 * 
 * @asparam mediatorName name of the <code>IMediator</code> to be removed.
 * @asreturn the <code>IMediator</code> that was removed from the <code>View</code>
 * @export
 * @param {string} mediatorName
 * @return {org.puremvc.as3.multicore.interfaces.IMediator}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.removeMediator = function(mediatorName) {
  var /** @type {org.puremvc.as3.multicore.interfaces.IMediator} */ mediator;
  if (this.view != null)
    mediator = this.view.removeMediator(mediatorName);
  return mediator;
};


/**
 * Check if a Mediator is registered or not
 * 
 * @asparam mediatorName
 * @asreturn whether a Mediator is registered with the given <code>mediatorName</code>.
 * @export
 * @param {string} mediatorName
 * @return {boolean}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.hasMediator = function(mediatorName) {
  return this.view.hasMediator(mediatorName);
};


/**
 * Create and send an <code>INotification</code>.
 * 
 * <P>
 * Keeps us from having to construct new notification 
 * instances in our implementation code.
 * @asparam notificationName the name of the notiification to send
 * @asparam body the body of the notification (optional)
 * @asparam type the type of the notification (optional)
 * @export
 * @param {string} notificationName
 * @param {Object=} body
 * @param {string=} type
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.sendNotification = function(notificationName, body, type) {
  body = typeof body !== 'undefined' ? body : null;
  type = typeof type !== 'undefined' ? type : null;
  this.notifyObservers(new org.puremvc.as3.multicore.patterns.observer.Notification(notificationName, body, type));
};


/**
 * Notify <code>Observer</code>s.
 * <P>
 * This method is left public mostly for backward 
 * compatibility, and to allow you to send custom 
 * notification classes using the facade.</P>
 *<P> 
 * Usually you should just call sendNotification
 * and pass the parameters, never having to 
 * construct the notification yourself.</P>
 * 
 * @asparam notification the <code>INotification</code> to have the <code>View</code> notify <code>Observers</code> of.
 * @export
 * @param {org.puremvc.as3.multicore.interfaces.INotification} notification
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.notifyObservers = function(notification) {
  if (this.view != null)
    this.view.notifyObservers(notification);
};


/** 
 * Set the Multiton key for this facade instance.
 * <P>
 * Not called directly, but instead from the 
 * constructor when getInstance is invoked. 
 * It is necessary to be public in order to 
 * implement INotifier.</P>
 * @export
 * @param {string} key
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.initializeNotifier = function(key) {
  this.multitonKey = key;
};


/**
 * Check if a Core is registered or not
 * 
 * @asparam key the multiton key for the Core in question
 * @asreturn whether a Core is registered with the given <code>key</code>.
 * @export
 * @param {string} key
 * @return {boolean}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.hasCore = function(key) {
  return (org.puremvc.as3.multicore.patterns.facade.Facade.instanceMap[key] != null);
};


/**
 * Remove a Core.
 * <P>
 * Remove the Model, View, Controller and Facade 
 * instances for the given key.</P>
 * 
 * @asparam multitonKey of the Core to remove
 * @export
 * @param {string} key
 */
org.puremvc.as3.multicore.patterns.facade.Facade.removeCore = function(key) {
  if (org.puremvc.as3.multicore.patterns.facade.Facade.instanceMap[key] == null)
    return;
  org.puremvc.as3.multicore.core.Model.removeModel(key);
  org.puremvc.as3.multicore.core.View.removeView(key);
  org.puremvc.as3.multicore.core.Controller.removeController(key);
  delete org.puremvc.as3.multicore.patterns.facade.Facade.instanceMap[key];
};


/**
 * @protected
 * @type {org.puremvc.as3.multicore.interfaces.IController}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.controller;


/**
 * @protected
 * @type {org.puremvc.as3.multicore.interfaces.IModel}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.model;


/**
 * @protected
 * @type {org.puremvc.as3.multicore.interfaces.IView}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.view;


/**
 * @protected
 * @type {string}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.multitonKey;


/**
 * @protected
 * @type {Array}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.instanceMap = new Array();


/**
 * @protected
 * @const
 * @type {string}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.MULTITON_MSG = "Facade instance for this Multiton key already constructed!";


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.FLEXJS_CLASS_INFO = { names: [{ name: 'Facade', qName: 'org.puremvc.as3.multicore.patterns.facade.Facade', kind: 'class' }], interfaces: [org.puremvc.as3.multicore.interfaces.IFacade] };


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('org.puremvc.as3.multicore.patterns.facade.Facade', org.puremvc.as3.multicore.patterns.facade.Facade);



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.puremvc.as3.multicore.patterns.facade.Facade.prototype.FLEXJS_REFLECTION_INFO = function () {
  return {
    variables: function () {return {};},
    accessors: function () {return {};},
    methods: function () {
      return {
        'Facade': { type: '', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'getInstance': { type: 'org.puremvc.as3.multicore.interfaces.IFacade', isStatic: true , declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'registerCommand': { type: 'void', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false },{ index: 2, type: 'Class', optional: false } ]; }},
        'removeCommand': { type: 'void', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'hasCommand': { type: 'Boolean', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'registerProxy': { type: 'void', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'org.puremvc.as3.multicore.interfaces.IProxy', optional: false } ]; }},
        'retrieveProxy': { type: 'org.puremvc.as3.multicore.interfaces.IProxy', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'removeProxy': { type: 'org.puremvc.as3.multicore.interfaces.IProxy', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'hasProxy': { type: 'Boolean', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'registerMediator': { type: 'void', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'org.puremvc.as3.multicore.interfaces.IMediator', optional: false } ]; }},
        'retrieveMediator': { type: 'org.puremvc.as3.multicore.interfaces.IMediator', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'removeMediator': { type: 'org.puremvc.as3.multicore.interfaces.IMediator', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'hasMediator': { type: 'Boolean', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'sendNotification': { type: 'void', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false },{ index: 2, type: 'Object', optional: true },{ index: 3, type: 'String', optional: true } ]; }},
        'notifyObservers': { type: 'void', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'org.puremvc.as3.multicore.interfaces.INotification', optional: false } ]; }},
        'initializeNotifier': { type: 'void', declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'hasCore': { type: 'Boolean', isStatic: true , declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'removeCore': { type: 'void', isStatic: true , declaredBy: 'org.puremvc.as3.multicore.patterns.facade.Facade', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }}
      };
    }
  };
};